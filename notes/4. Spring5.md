# Spring

## 1. 概述

理念：简化服务器开发，使现有的技术更加容易使用，本身就是大杂烩，整合了现有的技术框架

SSM：SpringMVC , Spring, Mybatis

优点：

- Spring开源免费的框架（容器）

- Spring是一个轻量级、非入侵式的框架
- **控制反转（IOC），面向切面编程(AOP)**
- 支持事务的处理，对框架整合的支持



组成：

![image-20220420190405726](appendix\4. Spring5\image-20220420190405726.png)



现代化的java开发

- Spring boot （构建一切）

  快速开发的脚手架

  基于SpringBoot可以快速的开发单个微服务

  约定大于配置

- Spring Cloud是基于SpringBoot（协调一切）

  

## 2. IOC理论推导

![image-20220420193619183](appendix\4. Spring5\image-20220420193619183.png)

1.UserDao接口

2.UserDaolmpl 实现类

3.UserService 业务接口

4.Userservicelmpl 业务实现类



程序适应不了客户的变更，使用set接口实现

- 之前程序是主动创建对象，控制权在程序员手上
- 使用了set注入后，程序不再有主动权，二手被动的接受对象！

这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建，系统得耦合性大大降低，可以更加专注在业务的实现，这是IOC的原型，**控制反转**。

![image-20220420192926483](appendix\4. Spring5\image-20220420192926483.png)



IOC本质

![image-20220420193135853](appendix\4. Spring5\image-20220420193135853.png)

**控制反转是一种通过描述（xml或者注解），并通过第三方去生产或获取特定对象的方式，在spring中实现控制反转的是ioc容器，DI（依赖注入）是实现ioc的一种方式。**



## 3. java bean的理解

java beans的意思是java类

使用Spring来创建对象，在Spring这些都称为bean

> java语句：类型 变量名 = new 类型();
>
> bean => 对象  new Hello();
>
> id => 变量名
>
> class => new的对象,bean对象所对应的全限定名：包名+类型
>
> property 相当于给对象中的属性赋值
>
> - value是赋值，具体的值，基本数据类型
> - ref是引用Spring容器中创建好的对象

```java
<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8"></property>
        <property name="username" value="root"></property>
        <property name="password" value="132"></property>
</bean>

```

```java
//
public class Test {
    @org.junit.Test
    public void test() {
        //获取ApplicationContext，拿到Spring容器
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        //强转
        //也可以不强转，利用反射
        UserMapper mapper = (UserMapper) context.getBean("UserMapperImple1");
        List<User> userList = mapper.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }
    }
}
```



我们的对象现在都在spring中管理，我们要使用，直接从里面取出getBean，这就是ioc，对象由spring创建，管理，分配



## 4. Spring配置

### property

```xml
<!--name可以取多个，逗号隔开-->
<property name="configLocation" alias = "alias" value="classpath:mybatis-config.xml"></property>
```

### import

一般用于团队开发，可以将多个配置文件，导入合并为一个，使用的时候直接使用这个总的配置就可以





## 5. 依赖注入

### 5.1 构造器注入

 IOC创建对象的方式

- 使用无参构造对象，默认！

- 有参：三种

  ```xml
  <constructor-arg index="0" value="1"/>
  <!--不建议使用-->
  <constructor-arg type="java.lang.Sting" value="1"/>
  <!--建议使用-->
  <constructor-arg name="name" value="1"/>
  ```

- Spring 在配置文件加载的时候，只要启动，容器中管理的对象就直接实例化了，要用就get

  

### * 5.2 set方式注入

依赖注入：set注入

依赖：bean对象的创建依赖于容器

注入：bean对象中的所有属性，由容器来注入

```xml
<bean id="student" class="cn.di.spring.Student">
        <!--第1种：普通值注入：value-->
        <property name="name" value="张三"/>
        <!--第2种：bean注入：ref-->
        <property name="address" ref="address"/>
        <!--第3种：数组注入：-->
        <property name="books">
            <array>
                <value>西游记</value>
                <value>水浒传</value>
                <value>红楼梦</value>
            </array>
        </property>
        <!--第4种：list注入：-->
        <property name="hobby">
            <list>
               <value>打球</value>
               <value>唱歌</value>
               <value>代码</value>
            </list>
        </property>
        <!--第5种：map注入：-->
        <property name="card">
            <map>
               <entry key="身份证" value="000545"/>
               <entry key="银行卡" value="111454"/>
            </map>
        </property>
        <!--第6种：Set注入：-->
        <property name="games">
            <set>
                <value>LOL</value>
                <value>COC</value>
                <value>BOB</value>
            </set>
        </property>
        <!--第7种：null值注入：-->
        <property name="wife">
            <null/>
        </property>
        <!--第8种：Properties注入：key=value -->
        <property name="info">
          <props>
              <prop key="学号">193102008</prop>
              <prop key="性别">男</prop>
              <prop key="姓名">张三</prop>
          </props>
        </property>
    </bean>
```



### 5.3 扩展方式注入

需要引入约束，namespace

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       
       <!--    p(property)可以直接注入属性的值-->
		<bean id="user" class="com.edu.zut.pojo.UserDi" p:name="Weining" p:age="18"/>
		<!-- c (construct)通过构造器注入-->
		<bean id="userc" class="com.edu.zut.pojo.UserDi" c:name="Weining" c:age="12"/>
</beans>
```



### 5.4 作用域

```xml
bean的作用域可以通过scope属性来指定bean的作用域
1、singleton:默认值。当IOC容器一创建就会创建bean的实例，而且是单例的，每次得到同一个。(尽量使用单例)
2、prototype:原型的。当IOC容器一创建不再实例化该bean，每次调用getBean方法时再实例化该bean，而且每次调用都会返回一个新的实例
3、request：每次HTTP请求都会创建一个新的Bean,该作用域仅适用于WebApplicationContext环境
4、session：同一个HTTP Session 共享一个Bean,不同的 HTTP Session 使用不同的Bean. 该作用域仅适用于WebApplicationContext环境。
```



## 6. bean的自动装配

spring会在上下文自动寻找，并自动给bean装配属性。自动装配就是指 Spring 容器在不使用 <constructor-arg> 和<property> 标签的情况下，可以自动装配（autowire）相互协作的 Bean 之间的关联关系，将一个 Bean 注入其他 Bean 的 Property 中。



### 6.1 Spring中的三种装配

- xml
- java
- 隐式自动装配【重要】



### 6.2 xml

```xml
<!--
1.byName
  - 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。
  - 去spring容器中寻找是否有此字符串名称id的对象。
  - 如果有，就取出注入；如果没有，就报空指针异常。
  - 保证id唯一-->
<bean id="person" class="com.pojo.Person" autowire="byName">
        
<!--
2.byType
  - 如果您有相同类型的多个 Bean，则注入失败，并且引发异常
  - 保证class唯一-->
<bean id="person" class="com.pojo.Person" autowire="byType"/>
    
<!--
3.constructor
  - 如果您有相同类型的多个 Bean，则注入失败，并且引发异常-->
<bean id="person" class="com.pojoPerson" autowire="constructor"/>

<!--
4.no
  - 不使用自动装配-->
<bean id="person" class="com.pojo.Person" autowire="no">
     <constructor-arg ref="man" type="com.pojo.Man"/>
</bean>
```



### 6.3 注解

注意：

- 导入约束

- **Spring 默认不使用注解装配 Bean，因此需要在配置文件中添加 <context:annotation-config/>，启用注解。**

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
          https://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context
          https://www.springframework.org/schema/context/spring-context.xsd
          http://www.springframework.org/schema/aop
          https://www.springframework.org/schema/aop/spring-aop.xsd">
   
      <!--开启注解的支持-->
      <context:annotation-config/>
   
      <bean id="cat1" class="com.kuang.pojo.Cat"/>
      <bean id="cat2" class="com.kuang.pojo.Cat"/>
      <bean id="dog132" class="com.kuang.pojo.Dog"/>
      <bean id="people" class="com.kuang.pojo.People"/>
   
  </beans>
  ```

  

#### 6.3.1 Autowired

@Autowired：

- 可在属性、Set上使用

- 可以不用编写Set方法 ,前提是符合byName的要求

- 按类型自动转配的不支持id匹配

- 需要导入 spring-aop的包

- 允许对象为null

  ```java
  //如果允许对象为null，设置required = false,默认为true
  @Autowired(required = false)
  private Cat cat;
  ```



#### 6.3.2 Autowired和Qualifier

@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配

- @Qualifier不能单独使用,和Autowired搭配使用

  ```java
  @Autowired
  @Qualifier(value = "cat2")
  private Cat cat;
  @Autowired
  @Qualifier(value = "dog2")
  private Dog dog;
  ```



#### 6.3.3 Resource

@Resource如有指定的name属性，先按该属性进行byName方式查找装配；

- 这是java的元注解

- @Resource如有指定的name属性，先按该属性进行byName方式查找装配；

- 其次再进行默认的byName方式进行装配；

- 如果以上都不成功，则按byType的方式自动装配。

- 都不成功，则报异常。

  ```java
      @Resource(name = "cat2")
      private Cat cat;
   
      @Resource
      private Dog dog;
      private String name;
  ```

  

小结：

@Resource和@Autowired的区别:

- 都是用来自动装配的，都可以放在属性字段正Autowired通过byname的方式实现

- @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现!





## 7. 使用注解开发

### 7.1 前提

- aop包必须导入

- 约束必须导入

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
          https://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context
          https://www.springframework.org/schema/context/spring-context.xsd
          http://www.springframework.org/schema/aop
          https://www.springframework.org/schema/aop/spring-aop.xsd">
      
   	<!--指定要扫描的包，这个包下的注解就会生效-->
  	<context:component-scan base-package="com.gongyi"/>
      <!--开启注解的支持-->
      <context:annotation-config/>
   
      <bean id="cat1" class="com.kuang.pojo.Cat"/>
  </beans>
  ```

  

### 7.2 注解

简单的情况可以使用注解

不是自己的类不能使用，维护相对复杂

- bean注入：@Component

- 属性注入：@Value("gongyi")

- 作用域

  ```java
  //等价于<bean id="user" class="com.gongyi.pojo.User"/>
  //@Component组件
  @Component
  @Scope("singleton")
  public class User {
      // 相当于<property name="name" value="gongyi"/>
      @Value("gongyi")
      public String name;
      //@Value("muzi")
      public void setName(String name) {
          this.name = name;
      }
  }
  ```

- 衍生注解

  在web开发中，会按照mvc三层架构分层，其实本质都是bean（类）

  都代表将某个类注册到Spring中

  - dao【@Repository】 
  - service【@Service】
  - controller【@Controller】



最佳实践：

- xml管理bean

- 注解只负责完成属性的注入



## 8. 使用java的方式配置Spring

不使用xml了，全权交给java

