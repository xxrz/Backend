# **Spring**

## 1. **IoC**

IoC: 控制反转，意思就是将创建对象的控制权从⾃⼰硬编码new的⼀个对象反转到了第三⽅身上。

IoC的主要实现⽅式是依赖注⼊，Spring中的依赖注⼊⽅式有：构造⽅法注⼊、settter注⼊、接⼝注⼊？。

**⽬的：**

帮助我们接耦各种有依赖关系的业务对象之间的绑定关系



## 2. **IoC-Provider**

虽然不需要我们⾃⼰来做绑定关系，但是这部分的⼯作还是需要有⼈来实现的，所以IoC Provider就担任了这个⻆⾊，同时IoC Provider的职责也不仅仅这些，其基础职责如下： 

- 业务对象的构建管理：

  IoC中，业务对象不需要关⼼所依赖的对象如何构建如何获取，这部分任务交由IoC Provider 

- 业务对象之间的依赖绑定：

  通过结合之前构建和管理的所有业务对象，以及各个业务对象之间可识别的依赖关系，将这些对象所依赖的对象注⼊绑定。从⽽保证每个业务对象在使⽤的时候，可以处于就绪状态。 



## 3. Spring的IoC容器（Bean的生命周期）

### 3.1 概述

担任了IoC Provider的职责，同时在此基础上，还增加了对Bean⽣命周期的管理、AOP⽀持内容。

从整体来看Spring的IoC容器的作⽤，共分为两部分：

- 容器启动阶段

  以某种⽅式将配置的Bean信息（XML、注解、Java编码）加载如整个Spring应⽤ 

  - 配置元信息（Resource）：（XML、注解、Java编码）

  - **BeanDefination**：配置元信息被加载到内存之后是以BeanDefination的形存在的

  - **BeanDefinationReader**：加载配置元信息，并将其转化为内存形式的BeanDefination

  - **BeanDefinationRegistry**：BeanDefinationRegistry就是一个存放BeanDefination的大篮子，它也是一种键值对的形式，通过特定的Bean定义的id，映射到相应的BeanDefination。

  - **BeanFactoryPostProcessor**：是容器启动阶段Spring提供的一个扩展点（AOP）

    BeanFactoryPostProcessor会对注册到BeanDefinationRegistry中的BeanDefination做最后的修改，替换$占位符为配置文件中的真实的数据

- Bean实例化阶段

  将加载的Bean配置信息组装成应⽤需要的业务对象，加载方式分为两种

  - 非懒加载（默认）：容器启动后，立即实例化Bean，通过隐式的调用所有依赖对象的getBean方法来实例化所有配置的Bean并保存起来。
  - 懒加载：Spring只有在我们需要依赖对象的时候才开启相应对象的实例化阶段，再此之前都是BeanDefination的方式存在
  
  在此基础上，还充分运⽤了这两个阶段不同的特点，都预留了拓展钩⼦(AOP扩展点)，供我们根据业务场景进⾏⾃定义拓展



### 3.2 Bean的生命周期

参考：https://juejin.cn/post/6929672218322731022

从Bean的⻆度来看，其整个⽣命周期如下：

![image-20220421112317684](appendix\4. Spring5_1知识点\image-20220421112317684.png)

注意：Spring只帮我们管理单例Bean的⽣命周期，对于prototype类型的bean，Spring在创建好交给使⽤者使⽤之后，就不在管理其后续的⽣命周期了。 



**粗略涉及具体源码的整体流程：** 



== 容器启动阶段==

1. BeanDefinitionReader读取Bean的配置信息（XML等），将读取到的每个Bean的配置信息使⽤BeanDefinition表示，同时注册到相应的BeanDefinitionRegistry（⼀个map）中 。 

2. 通过实现了**BeanFactoryPostProcessor**的类，⾃定义修改BeanDefinition中的信息（如果有的话） 

   

== 实例化阶段==

3. Bean的实例化: 

   (1) **采⽤策略化bean的实例。**两种⽅式：cglib、**反射**

   ```java
   UserMapper mapper = (UserMapper) context.getBean("UserMapperImple1");
   ```

   (2) **设置对象属性，手动依赖注入**。获取Bean的实例之后，根据BeanDefinition中信息，填充Bean的属性、依赖注入 （IOC注入）

   ```java
       <bean id="UserMapperImple1" class="com.test.mapper.UserMapperImple1">
           <property name="sqlSessionFactory" ref="sqlSessionFactory"></property>
       </bean>
   ```

4. **检测各种Aware接⼝，自动注入相关依赖对象实例。**

   - 如果是**BeanFactory**（有点像SqlSessionTemplate）

     必须要在配置文件中或者使用注解的方式，将相关实例注册容器中，BeanFactory才可以为我们自动注入

   - **ApplicationContext**（有点像SqlSessionDaoSupport ）

     建立在BeanFactory 基础之上，当检测到Aware相关接口，ApplicationContext完全可以将自身注入到其中，通过**BeanPostProcessor**

5. 【AOP扩展点一】（类比动态代理部分invoke前添加的seeHouse方法）

   **调⽤BeanPostProcessor接⼝的初始化前方法**，处理符合要求的Bean实例【扩展点/AOP/代理】

6. **初始化**（两种方法）

   - 如果实现了**InitializingBean接⼝**，override对应的afterPropertiesSet()⽅法（或者通过注解，比如从数据库中给变量赋值）
   - 如果定义了**init-method参数**，执⾏对应的⾃定义初始化⽅法

7. 【AOP扩展点二】（类比动态代理部分invoke后添加的getMoney方法）

   **调⽤BeanPostProcessor的初始化后方法**

8. **自定义销毁逻辑**

   这一步对应自定义初始化逻辑，同样有两种方式

   - 实现**DisposableBean接口**
   - 配置**destory-method参数**（比如配置dataSource的时候destory-method为数据库连接的close()方法）

9. **bean对象放入mapper，使用bean**
10. 调用回调销毁接口
    - 判断Bean的Scope，如果是prototype类型，不再管理，用户管理
    - 如果是单例类型
      - 如果实现了DisposableBean接⼝，执⾏对应的destoy⽅法
      - 如果定义了destory-method，执⾏对应的⾃定义销毁⽅法



### 3.3 总结

#### 3.3.1 **两个拓展点：（AOP切面）**

- **BeanFactoryPostProcess**（初始化阶段） 

  Spring提供的容器扩展机制，允许我们在**bean实例化之前修改bean的定义信息**即BeanDefinition的信息 

- **BeanPostProcessor** （实例化阶段）

  也是Spring提供的容器扩展机制，不同于BeanFactoryPostProcessor的是，BeanPostProcessor在**bean实例化后修改bean或替换bean**。BeanPostProcessor是后⾯实现AOP的关键。 

  ApplicationContext对于Aware接口的检查与自动注入就是通过BeanPostProcessor实现的，在这一步Spring将检查Bean中是否实现了**相关的Aware接口**，如果是的话，那么就将其**自身注入Bean**中即可。Spring中AOP就是在这一步实现的偷梁换柱，产生对于原生对象的代理对象，然后将对源对象上的方法调用，转而使用代理对象的相同方法调用实现的。



#### 3.3.2 **BeanFactory和ApplicationContext**

Spring框架中，一旦把一个Bean纳入Spring IOC容器之中，这个Bean的生命周期就会交由容器进行管理，一般担当管理角色的是**BeanFactory或者ApplicationContext**

- Bean 工厂（com.springframework.beans.factory.BeanFactory）是Spring 框架最核心的接口，它提供了高级IoC 的配置机制。

- 应用上下文（com.springframework.context.ApplicationContext）建立在BeanFactory 基础之上。
  几乎所有的应用场合我们都直接使用ApplicationContext 而非底层的BeanFactory。

 ![image-20220421123001142](appendix\4. Spring5_1知识点\image-20220421123001142.png)

![image-20220421122945905](appendix\4. Spring5_1知识点\image-20220421122945905.png)



#### 3.3.3 **如何把类变成bean，用的什么注解**

Spring中的Bean简单来讲就是一个个被Spring容器管理的Java对象，我们写了一个类之后，这个类只是一个单纯的Java类，可以通过new的方式去创建它。当我们把这个类添加到Spring的容器里之后，这个类就变成了Bean，由Spring容器管理，可以通过自动注入的方式去使用。

https://juejin.cn/post/7017408619213750280

