参考：https://zhuanlan.zhihu.com/p/164812068

# MySQL题



## lEETCODE



### 1. where

#### [584. 寻找用户推荐人](https://leetcode-cn.com/problems/find-customer-referee/)

给定表 `customer` ，里面保存了所有客户信息和他们的推荐人。写一个查询语句，返回一个客户列表，列表中客户的推荐人的编号都 **不是** 2。

```sql
--注意id为空的情况
select name from customer
where referee_id <> 2 or referee_id is null
```

#### [595. 大的国家](https://leetcode-cn.com/problems/big-countries/)

如果一个国家满足下述两个条件之一，则认为该国是 大国 ：

    面积至少为 300 平方公里（即，3000000 km2），或者
    人口至少为 2500 万（即 25000000）

编写一个 SQL 查询以报告 大国 的国家名称、人口和面积。

```sql
select name, population, area from World
where area >= 3000000 or population >= 25000000
```



### 2. 表连接

#### [175. 组合两个表](https://leetcode-cn.com/problems/combine-two-tables/)(左连接)

编写一个SQL查询来报告 `Person` 表中每个人的姓、名、城市和状态。如果 `personId` 的地址不在 `Address` 表中，则报告为空  `null` 。

```sql
select FirstName as firstName, LastName as lastName, City as city, State as state 
from Person
left join Address
on Person.PersonId = Address.PersonId
```

#### [180. 连续出现的数字](https://leetcode-cn.com/problems/consecutive-numbers/)（自连接）

编写一个 SQL 查询，查找所有至少连续出现三次的数字。

返回的结果表中的数据可以按 **任意顺序** 排列。

```sql
select distinct a.Num as ConsecutiveNums 
from logs a
join logs b on a.Id = b.Id - 1
join logs c on a.Id = c.Id - 2
where a.Num = b.Num and b.Num = c.Num
```



### 3. group by

#### [182. 查找重复的电子邮箱](https://leetcode-cn.com/problems/duplicate-emails/)

编写一个 SQL 查询，查找 `Person` 表中所有重复的电子邮箱。

```sql
select Email from Person
group by Email
having count(Email) >= 2
```



### 4. **LIMIT**

#### [176. 第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary/)

编写一个 SQL 查询，获取并返回 `Employee` 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 `null` 。

```sql
# 将临时表的结果作为是否为null
select distinct (
    select distinct salary 
    from Employee 
    order by salary DESC
    limit 1,1
) as SecondHighestSalary
```



### 5. **IN操作符**

#### [1084. 销售分析III](https://leetcode-cn.com/problems/sales-analysis-iii/)

编写一个SQL查询，报告`2019年春季`才售出的产品。即**仅**在`**2019-01-01**`至`**2019-03-31**`（含）之间出售的商品。

```sql
select distinct Product.product_id, product_name
from Product
join Sales
on Product.product_id = Sales.product_id
where sale_date between '2019-01-01' and '2019-03-31'
and Sales.product_id not in (select product_id from Sales
where sale_date > '2019-03-31' or sale_date < '2019-01-01'
)
```

```sql
SELECT 
    s.product_id, p.product_name
FROM 
    sales s
LEFT JOIN 
    product p 
ON 
    s.product_id = p.product_id
GROUP BY 
    s.product_id
HAVING MIN(sale_date) >= '2019-01-01' 
AND MAX(sale_date) <= '2019-03-31';
```



### 6. date

#### [197. 上升的温度](https://leetcode-cn.com/problems/rising-temperature/)

编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 `id` 。

注意日期的比较：

| 函数          | 描述                                |
| ------------- | ----------------------------------- |
| NOW()         | 返回当前的日期和时间                |
| CURDATE()     | 返回当前的日期                      |
| CURTIME()     | 返回当前的时间                      |
| DATE()        | 提取日期或日期/时间表达式的日期部分 |
| EXTRACT()     | 返回日期/时间按的单独部分           |
| DATE_ADD()    | 给日期添加指定的时间间隔            |
| DATE_SUB()    | 从日期减去指定的时间间隔            |
| DATEDIFF()    | 返回两个日期之间的天数              |
| DATE_FORMAT() | 用不同的格式显示日期/时间           |

```sql
select distinct w1.id from 
Weather as w1
join Weather as w2
where datediff(w1.recordDate, w2.recordDate) = 1 and 
w2.temperature < w1.temperature
```



## 经典SQL语句面试题

参考：https://blog.csdn.net/vincerey/article/details/116403484

#### **表结构**

Student(Sno,Sname,Sage,Ssex) 学生表

Course(Cno,Cname,Tno) 课程表

SC(Sno,Cno,score) 成绩表

Teacher(Tno,Tname) 教师表



#### 题目

- 查询“001”课程比“002”课程成绩高的所有学生的学号

  ```sql
  -- 需要连表，不如临时表
  -- 还需要自连接
  -- 思路还是这样写比较好
  select a.Sno
  from (select Sno,score from SC where Cno=’001′) a,
  (select Sno,score from SC where Cno=’002′) b
  where a.score > b.score and a.Sno=b.Sno;
  ```

- 查询平均成绩大于60分的同学的学号和平均成绩

  ```sql
  -- 按学号分组
  -- 分组后算平均成绩
  select Sno, avg(score)
  from SC
  group by Sno 
  having avg(score)>60;
  ```

- 查询**所有**同学的学号、姓名、选课数、总成绩

  ```sql
  -- 不知道对不对
  select SC.Sno,Sname,count(SC.Cno),sum(score)
  from Student 
  left join SC on Student.Sno = Sc.Sno
  group by SC.Sno
  ```

  ```sql
  -- left outer join 和左连接一样
  -- 为什么分组要加Sname
  select Student.Sno,Student.Sname,count(SC.Cno),sum(score)
  from Student left Outer join SC on Student.Sno=SC.Sno
  group by Student.Sno,Sname
  ```

  

