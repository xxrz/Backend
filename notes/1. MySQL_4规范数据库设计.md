

# 规范数据库设计

## 1. 概述

**当数据库比较复杂时我们需要设计数据库**

### 1.1 必要性

**糟糕的数据库设计 :** 

- 数据冗余,存储空间浪费
- 数据更新和插入的异常【屏蔽使用无力外键】
- 程序性能差

**良好的数据库设计 :** 

- 节省数据的存储空间
- 能够保证数据的完整性
- 方便进行数据库应用系统的开发

 **软件项目开发周期中数据库设计 :**

- 需求分析阶段: 分析客户的业务和数据处理需求
- 概要设计阶段:设计数据库的E-R模型图 , 确认需求信息的正确和完整.

### 1.2 **设计数据库步骤**

- 收集信息

- - 与该系统有关人员进行交流 , 座谈 , 充分了解用户需求 , 理解数据库需要完成的任务.

- 标识实体[Entity]

- - 标识数据库要管理的关键对象或实体,实体一般是名词

- 标识每个实体需要存储的详细信息[Attribute]

- 标识实体之间的关系[Relationship]

前端模板：https://ant.design/index-cn



## 2. 三大范式

目前[关系数据库](https://baike.baidu.com/item/关系数据库/1237340)有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、[第四范式](https://baike.baidu.com/item/第四范式/3193985)(4NF）和[第五范式](https://baike.baidu.com/item/第五范式/5025271)（5NF，又称完美范式）。

而通常我们用的最多的就是第一范式（1NF）、第二范式（2NF）、第三范式（3NF），也就是本文要讲的“三大范式”。

（参考：https://www.cnblogs.com/wsg25/p/9615100.html）

### 2.1 第一范式（1NF)：列不可再分

第一范式要求数据库表的每一列都是不可分割的原子数据项。

例如：

![](appendix\范式1.png)

上表中的“家庭信息”和“学校信息”列中的信息还能继续划分，因此均不满足原子性的要求。
 故调整如下：

![范式2](appendix\范式2.png)

上表中的每一列，均不可再分，因此满足第一范式。



### 2.2 第二范式（2NF)：各属性完全依赖于主键

**在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）**

**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**

举例：

![](appendix\范式3.png)

在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成。主键【订单号，产品号】

若要满足第二范式，除主键外的其他列，都需与主键【订单号，产品号】相关。而“订单金额”和“订单时间”两列信息只与【订单号】相关，而与【产品号】无关。因此不满足2NF。
 故调整为两个表：

![范式4](appendix\范式4.png)

![范式5](appendix\范式5.png)

将“订单金额”和“订单时间”两列信息与“订单号”自成一表，剩余信息为一表，从而满足各属性完全依赖于主键。



### 2.3 第三范式（3NF)：属性直接依赖于主键，而不依赖于其它非主属性

**在2NF基础上，任何非主[属性](https://baike.baidu.com/item/属性)不依赖于其它非主属性（在2NF基础上消除传递依赖）**

**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**

【满足第一范式的情况下，每张表只描述一件事情】

举例：

![](appendix\范式6.png)

上表中的主键为：[学号]。所有属性都依赖于“学号”，满足2NF。
 但是，表中“班主任性别”和“班主任年龄”又依赖于“班主任姓名”，因此不满足 3NF。
 故调整如下：

​										![范式7](appendix\范式7.png)![范式8](appendix\范式8.png)

调整后的上表，在满足2NF下，以满足属性之间没有间接关联。



### 2.4 其他

- 原则
  - 范式的目的是为了设计一个结构合理、数据规范的数据库。
  - 但出于**规范性和性能**的考虑：
    - 关联查询的表不得超过三张
    - 故意增加某些表中的一些**冗余字段**将多表查询变成单表查询
    - 故意增加一些计算列将大数据量计算变成小数据量便于查询

- 码的概念（参考：https://www.cnblogs.com/lightice/p/12764782.html）

  - **候选码(码)**：设K为R<U,F>中的属性或属性组合，若U完全依赖K，则K为R的候选码。

    具体一些，比如一个学生表，有了学号可以查到一个学生所有个人信息，这就是所说的完全依赖。

  - **超码**：如果说U部分依赖K，则K为R的候选码，候选码是最小的超码，如果任意超码的真子集不能包括超码，则称其为候选码，超码包括候选码。

  - **主码**：若候选码只有一个，则该候选码为主码。若候选码多于一个，则选定其中一个为主码。候选码可以作为主码，主码一定是候选码，但候选码不一定是主码。

    ```tex
    理解：主码是人为挑选出来的，是随机的，不是确定的。
    
    实例：如果说有学生(学号,姓名,身份证)，候选码就是(学号,身份证)，主码可以是学号，也可以是身份证，随您喜欢
    ```

  - **主属性**：包含任何一个候选码的**属性集合**称为主属性。

  - **非主属性**（或**非码属性**）：不包含任何一个候选码的属性集合称为非主属性。

  - **全码**：所有属性都是候选码，则称为全码。

    例一：

    ```tex
    竞赛表（竞赛编号，竞赛名称，竞赛组织者） PS：竞赛名称和竞赛组织者都可以重复
    
    很明显可以看出【竞赛编号】能够唯一标识整张竞赛表，因此【候选码】是竞赛编号，并且仅此一个候选码，其他属性都不能唯一标识整张表，所竞赛编号同时也是【主码】。
    
    这时候判断一下这几个属性or属性组是否是【主属性】，（竞赛编号）（竞赛编号，竞赛名称）（竞赛名称，竞赛组织者）。
    1，（竞赛编号）只有一个属性，这个属性是【主码】，主码必定为【候选码】，因此属性含有一个候选码，这个属性是【主属性】。
    2，（竞赛编号，竞赛名称）有两个属性，其中竞赛编号是候选码，而竞赛名称不是候选码,前面有提到了，因为它跟候选码在同一个属性组里，所以，【竞赛名称】是【超码】，回过头来，最后得出该属性组含有了一个候选码，因此该属性组中的各个属性都是【主属性】。
    3，（竞赛名称，竞赛组织者）有两个属性，可以看出这两个属性都不是候选码，因此这个属性组不包含候选码，属性组中中得各个元素称为【非主属性】。
    ```

    <img src="appendix\码.png" style="zoom:30%;" />

- 依赖（参考：https://www.jianshu.com/p/abf48dfec989）

  若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。

  - **完全函数依赖**

    **定义：**设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。

    **举例：**在成绩表SG中，成绩完全函数依赖于（学号，CID（课程号））

  - **部分函数依赖**

    **定义：**设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。

    **说明：**假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X

    **举例：**学生表ST中（学号，姓名）->性别，但是存在学号->性别，所以称性别部分依赖于（学号，姓名）

  - **传递函数依赖**

    **定义：**设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。

    **说明：**假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X

    **举例：**关系S1（学号，系名，系主任），学号 → 系名，系名 → 系主任，并且系名 ！→ 学号，所以学号 → 系主任为传递函数依赖。

