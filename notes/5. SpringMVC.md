# SpringMVC

## 1. 定义

- 什么是MVC？

  MVC是model（模型）、view（视图）、controller（控制器）的缩写。是将**业务逻辑、数据、显示**分离的一种架构模式。其中，

  - model（dao、service）：数据模型，提供了**模型数据的查询和数据状态更新**等功能，包含数据和行为
  - view（jsp）：对**模型结果的展示**，即用户界面所看见的结果
  - controller（servlet）：负责**接受用户请求，将请求交给模型进行处理，并将处理的结果返回给视图，再由视图进行展示**。

  **最典型的MVC就是JSP + servlet + javabean的模式**

  ![image-20220428002153382](appendix\5. SpringMVC\image-20220428002153382.png)

- 什么是SpringMVC？

  - 基于Java实现MVC轻量级的Web框架，其核心是**DispatcherServlet**，其作用是将不同的请求分发到不同的处理器。**降低了视图与业务逻辑间的双向偶合**

  - MVC不是一种设计模式，**MVC是一种架构模式**

  [官方文档链接](https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web)
  
- **MVC框架要做哪些事情**

  1. 将url映射到java类或java类的方法 .
  2. 封装用户提交的数据 .
  3. 处理请求--调用相关的业务处理--封装响应数据 .
  4. 将响应的数据进行渲染 . jsp / html 等表示层数据 .



## 2.原理

> servlet转发和重定向的区别
>
> 前端 数据传输 实体类
>
> 实体类：用户名，密码，生日，爱好..
>
> 前端 ：用户名 密码
>
> 
>
> pojo：User（实体类所有属性）
>
> vo：（视图对象）UserVo（用户名 密码）
>
> dto：（数据传输对象）

#### SpringMVC简易原理

当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到**请求对应的实际控制器**，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。

![image-20220428002641869](appendix\5. SpringMVC\image-20220428002641869.png)

#### SpringMVC详细原理

![image-20220428002843523](appendix\5. SpringMVC\image-20220428002843523.png)

图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。

**简要分析执行流程**

- **接受并拦截请求**

1. DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。

> 假设请求的url为 : http://localhost:8080/SpringMVC/test
>
> ​	服务器域名：http://localhost:8080
> ​	服务器上的web站点：SpringMVC
> ​	控制器名：test
>
> 如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。

- **解析url，找到url对应的控制器，并返回给DispatcherServlet**

2. HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。
3. HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。
4. HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。

- **对应的控制器执行请求，并把结果返回给DispatcherServlet**

5. HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。
6. Handler让具体的Controller执行。
7. Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。
8. HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。

- **视图解析器解析内容并调用对应视图**

9. DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。
10. 视图解析器将解析的逻辑视图名传给DispatcherServlet。（/web-inf/jsp/hello.jsp）
11. DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。

- **最终视图呈现给用户**。





## 3. 实现第一个MVC程序（配置版）

注：本代码为说明SpringMVC执行原理，实际上使用时多用注解，可参考下一篇文章内容[实现第一个MVC程序（注解版）](https://blog.csdn.net/weixin_44382915/article/details/115487653)。

### 3.1 引入库

创建一个maven项目，右击module名添加web框架支持，并在pom.xml文件中加入依赖。

```xml
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.1.8.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>servlet-api</artifactId>
        <version>2.5</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet.jsp</groupId>
        <artifactId>jsp-api</artifactId>
        <version>2.0</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>jstl</artifactId>
        <version>1.2</version>
    </dependency>
</dependencies>

```

### 3.2 注册DispatcherServlet

在web.xml文件中注册DispatcherServlet，并关联SpringMVC的配置文件，设置servlet启动顺序。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--1.注册DispatcherServlet-->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml-->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc-servlet.xml</param-value>
        </init-param>
        <!--启动级别-1-->
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!--/ 匹配所有的请求；（不包括.jsp）-->
    <!--/* 匹配所有的请求；（包括.jsp）-->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>
```

### 3.3 配置SpringMVC配置文件

在resources目录下配置springmvc-servlet.xml配置文件。
 配置文件内容包括处理器映射器、处理器适配器、视图解析器、处理器绑定的跳转页面的bean。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--处理器映射器HandlerMapping:查找访问的url-->
    <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>

    <!--处理器适配器HandlerAdapter：controller将处理好的数据返回给HandlerAdapter-->
    <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>

    <!--视图解析器ViewResolver：将后端处理好的数据和视图传给DispatchServlet，DS再交给ViewResolver先解析一遍，确认无误再传给前端-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver">
        <!-- 拼接视图名称 WEB-INF/jsp/xxxxx.jsp -->
        <property name="prefix" value="/WEB-INF/jsp/" />
        <property name="suffix" value=".jsp" />
    </bean>

    <!--BeanNameUrlHandlerMapping处理器：绑定请求页面的url，绑定操作业务的控制器-->
    <bean id="/hello" class="com.test.controller.HelloController"/>
</beans>
```

### 3.4 配置操作业务的控制器

```java
package com.test.controller;

import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//controller 处理请求并返回一个ModelAndView，实现接口Controller的类就是一个控制器。
public class HelloController implements Controller {

    @Override
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        ModelAndView mav = new ModelAndView();

        // 业务代码
        String result = "HelloSpringMVC!"; // 假设这个为调用业务代码的返回值。
        mav.addObject("msg", result);

        // 视图跳转到hello.jsp
        mav.setViewName("hello"); //: /WEB-INF/jsp/hello.jsp

        return mav;
    }
}

```

### 3.5 设置一个测试使用的视图页面

在目录WEB-INF/jsp/下建立一个测试页面test.jsp

```xml
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
${msg}
</body>
</html>
```

### 3.6 测试

打包需要检查依赖是否也打入

![image-20220506001125211](appendix\5. SpringMVC\image-20220506001125211.png)



## 4. 实现一个MVC程序（注解版）

### 4.1 引入库

创建一个maven项目，右击module名添加web框架支持，并在pom.xml文件中加入依赖。

```xml
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.1.8.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>servlet-api</artifactId>
        <version>2.5</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet.jsp</groupId>
        <artifactId>jsp-api</artifactId>
        <version>2.0</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>jstl</artifactId>
        <version>1.2</version>
    </dependency>
</dependencies>
```

### 4.2 注册DispatcherServlet

在web.xml文件中注册DispatcherServlet，并关联[SpringMVC](https://so.csdn.net/so/search?q=SpringMVC&spm=1001.2101.3001.7020)的配置文件，设置servlet启动顺序。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!--注册DispatcherServlet-->
    <servlet>
        <servlet-name>SpringMVC</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--关联SpringMVC配置文件的位置，配置文件写在resources目录下 -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc-servlet.xml</param-value>
        </init-param>
        <!-- 启动顺序，数字越小，启动越早，1为和服务器一同启动 -->
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!--所有请求都会被SpringMVC拦截，即DispatcherServlet -->
    <servlet-mapping>
        <servlet-name>SpringMVC</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

</web-app>

```

### 4.3 配置SpringMVC配置文件

在resources目录下配置springmvc-[servlet](https://so.csdn.net/so/search?q=servlet&spm=1001.2101.3001.7020).xml配置文件。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">


    <!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 -->
    <context:component-scan base-package="com.test.controller"/>
    
    <!-- 过滤：让Spring MVC不处理静态资源 -->
    <mvc:default-servlet-handler />
    
    <!--引入mvc注解驱动，使@RequestMapping注解生效，即自动完成DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter实例的注入 -->
    <mvc:annotation-driven />


    <!-- 视图解析器 -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"
          id="internalResourceViewResolver">
        <!-- 前缀 -->
        <property name="prefix" value="/WEB-INF/jsp/" />
        <!-- 后缀 -->
        <property name="suffix" value=".jsp" />
    </bean>
</beans>

```

### 4.4 配置操作业务的控制器

各注解含义：
1）@Controller：标注该类是一个控制器。

    目的为解析用户的请求并将其转换为一个模型，可让Spring IOC容器初始化时能自动扫描到。
    一个控制类可包含多个方法，例如示例一和示例二，可使用不同的路径调转同一jsp内产生不同的返回结果。

2）@RequestMapping：标注请求的地址路径。

    可标注在类名前，则该类中的其他方法的访问地址都在此路径下。也可表示在方法类上，指明该方法的方法路径（如示例一）。
    可使用RestFul风格，隐藏参数名传入参数值。如示例三，@PathVariable标注需要传入的参数，并以{}的形式在@RequestMapping说明。
    @GetMapping：用于约束请求的类型，可以收窄请求范围。如示例三，指定请求类型为get。还有@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping请求。
```java
package com.test.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/HelloController")
public class HelloController {

    // 示例一：
    //真实访问地址 : 项目名/HelloController/hello
    @RequestMapping("/hello")
    public String sayHello(Model model){
        //向模型model中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute("msg","hello,SpringMVC");
        //web-inf/jsp/hello.jsp 返回视图名称
        return "hello";
    }

    // 示例二：
    @RequestMapping("/test1")
    public String test1(Model model){
        //向模型model中添加属性msg与值，可以在JSP页面中取出并渲染
        model.addAttribute("msg","test1 SpringMVC");
        //web-inf/jsp/test.jsp 返回视图名称
        return "test";
    }

    // 示例三：
    @RequestMapping("/test/{p1}/{p2}")
//    @GetMapping("/test/{p1}/{p2}")
    public String test(@PathVariable int p1, @PathVariable int p2, Model model){
        int result = p1 + p2;
        model.addAttribute("msg",result);

        return "test"; // 默认页面为转发的方式
        // return "redirect:/hello"; // 重定向到/hello路径
    }
}
```

### 4.5 设置一个测试使用的视图页面。

在目录WEB-INF/jsp/下建立一个测试页面test.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
${msg}
</body>
</html>
```

### 4.6 测试

改了java的代码需要reloade

改了配置文件需要重新发布tomcat

只改了前端页面刷新一下



## 5.restful风格

https://blog.csdn.net/qq_43560701/article/details/120023290

首先，互联网上的信息都可以被抽象为资源，用户可以发起请求对这些资源进行操作，操作的方式如：POST、DELETE、PUT、GET，对应增加、删除、修改、查询（不是全部）！

按照之前的方式，发起请求操作资源时，请求的格式为

    增加：127.0.0.1/item/add.action?id=1
    删除：127.0.0.1/item/delete.action?id=1
    修改：127.0.0.1/item/update.action
    查询：127.0.0.1/item/select.action

若使用 REST 风格，请求就可以为

    增加：127.0.0.1/item/1，POST
    删除：127.0.0.1/item/1，DELETE
    修改：127.0.0.1/item，PUT
    查询：127.0.0.1/item，GET

RESTFUL 的特点为

    每一个URI代表1种资源
    客户端使用 GET、POST、PUT、DELETE 等表示操作方式的动词对服务端资源进行操作
    通过操作资源的表现形式来操作资源（不懂）
    资源的表现形式是XML或者HTML（不懂）

简而言之，REST 风格即通过 URL 定位资源，用 HTTP 描述操作！

```java
    @GetMapping
    @PostMapping
    @PutMapping
    @DeleteMapping
    ...
```



RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http很好的诠释。
对url进行规范，写RESTful格式的url 
非REST的url：http://../query.action?id=3&type=t01（传递的数据大小有限制）
 REST的url风格：http://../query/3/t01[需要服务端指定是什么参数，如下图a,b]
 特点：url简洁，将参数通过url传到服务端

**浏览器 URL 默认的请求方法是 GET**

![image-20220507005145352](appendix\5. SpringMVC\image-20220507005145352.png)

把请求参数加入到请求的资源地址中
 原来的增，删，改，查。使用HTTP请求方式，POST、DELETE、PUT、GET分别一一对应。

![image-20220507010004234](appendix\5. SpringMVC\image-20220507010004234.png)

安全 隐藏参数



## 6. 结果跳转方式

### ModelAndView

视图解析器用于路径拼接而已

页面：视图解析器前缀+viewName+后缀

**通过 ModelAndView 的 setViewName 方法设置返回的视图名字，再返回这个 mv 对象，视图解析器解析其中的视图名字。**

```java
public class ControllerMAV implements Controller {

    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        // 获取本次会话的 Session
        HttpSession session = httpServletRequest.getSession();
        String id = session.getId();
        // 放信息，设视图
        ModelAndView mv = new ModelAndView();
        mv.addObject("msg",id);
        mv.setViewName("test");

        return mv;
    }
}
```

### ServletAPI

**转发**或**重定向**, 这种方式就不需要视图解析器了！

复习一下转发和重定向的区别：

- **转发**是服务器内部行为，用户只发起一次请求
- **重定向**是服务器返回另一请求给用户，用户发起二次请求

```java
@Controller
public class ControllerSAPI {
    
    @RequestMapping("/testsapi/forward")
    public void TestF(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 用原生 API 当然需要这两个参数了
        req.setAttribute("msg","转发啦");
        req.getRequestDispatcher("/WEB-INF/jsp/test.jsp").forward(req,resp);
    }

    @RequestMapping("/testsapi/redirect")
    public void TestR(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 用原生 API 当然需要这两个参数了
        req.setAttribute("msg","重定向啦");
        // 重定向就访问不了被保护的 WEB-INF 目录了！！！
        // 由客户端发起二次请求，要带上项目路径！！！
        resp.sendRedirect(req.getServletContext().getContextPath()+"/index.jsp");
    }
}
```

### SpringMVC

用 SpringMVC 的方式实现一下 ServletAPI 做的转发和重定向，也是不需要视图解析器的（直接一步到位了，当然只是演示用）！

编写 ControllerSMVC 类，添加 @Controller 注解

```java
@Controller
public class ControllerSMVC {

    @RequestMapping("/testsmvc/forward")
    public String TestF(Model model){
        model.addAttribute("msg","Qiyuan转发！");
        // 转发：url没有变
        // 没有视图解析器当然要手动拼接辽
        return "forward:/WEB-INF/jsp/test.jsp";
        //return "/WEB-INF/jsp/test.jsp";
    }

    @RequestMapping("/testsmvc/redirect")
    public String TestM(Model model){
        model.addAttribute("msg","Qiyuan重定向！");
        // 重定向：url会变
        // 这里和直接用 Servlet 不一样！SpringMVC 会自动补上项目路径！
        return "redirect:/index.jsp";
    }
}
```

**主要是通过返回的字符串中的 forward 和 redirect 关键字实现的！**

### Model

这就是使用注解后的方式了！

编写 ControllerM 类，添加 @Controller 注解

```java
@Controller
public class ControllerM {
    @RequestMapping("/testm")
    public String TestM(Model model, HttpServletRequest req, HttpServletResponse resp){
        // 获取本次会话的 Session
        HttpSession session = req.getSession();
        String id = session.getId();
        // 放信息
        model.addAttribute("msg",id);
        return "test";
    }
}
```

**通过直接返回 String 字符串设置要跳转的视图，这个 String 字符串就是视图名字。**